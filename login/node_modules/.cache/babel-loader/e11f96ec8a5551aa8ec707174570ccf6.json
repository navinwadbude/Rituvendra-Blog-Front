{"ast":null,"code":"const minimatch = require('minimatch');\n\nconst path = require('path');\n\nconst fs = require('fs');\n\nconst debug = require('debug')('nodemon:match');\n\nconst utils = require('../utils');\n\nmodule.exports = match;\nmodule.exports.rulesToMonitor = rulesToMonitor;\n\nfunction rulesToMonitor(watch, ignore, config) {\n  var monitor = [];\n\n  if (!Array.isArray(ignore)) {\n    if (ignore) {\n      ignore = [ignore];\n    } else {\n      ignore = [];\n    }\n  }\n\n  if (!Array.isArray(watch)) {\n    if (watch) {\n      watch = [watch];\n    } else {\n      watch = [];\n    }\n  }\n\n  if (watch && watch.length) {\n    monitor = utils.clone(watch);\n  }\n\n  if (ignore) {\n    [].push.apply(monitor, (ignore || []).map(function (rule) {\n      return '!' + rule;\n    }));\n  }\n\n  var cwd = process.cwd(); // next check if the monitored paths are actual directories\n  // or just patterns - and expand the rule to include *.*\n\n  monitor = monitor.map(function (rule) {\n    var not = rule.slice(0, 1) === '!';\n\n    if (not) {\n      rule = rule.slice(1);\n    }\n\n    if (rule === '.' || rule === '.*') {\n      rule = '*.*';\n    }\n\n    var dir = path.resolve(cwd, rule);\n\n    try {\n      var stat = fs.statSync(dir);\n\n      if (stat.isDirectory()) {\n        rule = dir;\n\n        if (rule.slice(-1) !== '/') {\n          rule += '/';\n        }\n\n        rule += '**/*'; // `!not` ... sorry.\n\n        if (!not) {\n          config.dirs.push(dir);\n        }\n      } else {\n        // ensures we end up in the check that tries to get a base directory\n        // and then adds it to the watch list\n        throw new Error();\n      }\n    } catch (e) {\n      var base = tryBaseDir(dir);\n\n      if (!not && base) {\n        if (config.dirs.indexOf(base) === -1) {\n          config.dirs.push(base);\n        }\n      }\n    }\n\n    if (rule.slice(-1) === '/') {\n      // just slap on a * anyway\n      rule += '*';\n    } // if the url ends with * but not **/* and not *.*\n    // then convert to **/* - somehow it was missed :-\\\n\n\n    if (rule.slice(-4) !== '**/*' && rule.slice(-1) === '*' && rule.indexOf('*.') === -1) {\n      if (rule.slice(-2) !== '**') {\n        rule += '*/*';\n      }\n    }\n\n    return (not ? '!' : '') + rule;\n  });\n  return monitor;\n}\n\nfunction tryBaseDir(dir) {\n  var stat;\n\n  if (/[?*\\{\\[]+/.test(dir)) {\n    // if this is pattern, then try to find the base\n    try {\n      var base = path.dirname(dir.replace(/([?*\\{\\[]+.*$)/, 'foo'));\n      stat = fs.statSync(base);\n\n      if (stat.isDirectory()) {\n        return base;\n      }\n    } catch (error) {// console.log(error);\n    }\n  } else {\n    try {\n      stat = fs.statSync(dir); // if this path is actually a single file that exists, then just monitor\n      // that, *specifically*.\n\n      if (stat.isFile() || stat.isDirectory()) {\n        return dir;\n      }\n    } catch (e) {}\n  }\n\n  return false;\n}\n\nfunction match(files, monitor, ext) {\n  // sort the rules by highest specificity (based on number of slashes)\n  // ignore rules (!) get sorted highest as they take precedent\n  const cwd = process.cwd();\n  var rules = monitor.sort(function (a, b) {\n    var r = b.split(path.sep).length - a.split(path.sep).length;\n    var aIsIgnore = a.slice(0, 1) === '!';\n    var bIsIgnore = b.slice(0, 1) === '!';\n\n    if (aIsIgnore || bIsIgnore) {\n      if (aIsIgnore) {\n        return -1;\n      }\n\n      return 1;\n    }\n\n    if (r === 0) {\n      return b.length - a.length;\n    }\n\n    return r;\n  }).map(function (s) {\n    var prefix = s.slice(0, 1);\n\n    if (prefix === '!') {\n      if (s.indexOf('!' + cwd) === 0) {\n        return s;\n      } // if it starts with a period, then let's get the relative path\n\n\n      if (s.indexOf('!.') === 0) {\n        return '!' + path.resolve(cwd, s.substring(1));\n      }\n\n      return '!**' + (prefix !== path.sep ? path.sep : '') + s.slice(1);\n    } // if it starts with a period, then let's get the relative path\n\n\n    if (s.indexOf('.') === 0) {\n      return path.resolve(cwd, s);\n    }\n\n    if (s.indexOf(cwd) === 0) {\n      return s;\n    }\n\n    return '**' + (prefix !== path.sep ? path.sep : '') + s;\n  });\n  debug('rules', rules);\n  var good = [];\n  var whitelist = []; // files that we won't check against the extension\n\n  var ignored = 0;\n  var watched = 0;\n  var usedRules = [];\n  var minimatchOpts = {\n    dot: true\n  }; // enable case-insensitivity on Windows\n\n  if (utils.isWindows) {\n    minimatchOpts.nocase = true;\n  }\n\n  files.forEach(function (file) {\n    file = path.resolve(cwd, file);\n    var matched = false;\n\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].slice(0, 1) === '!') {\n        if (!minimatch(file, rules[i], minimatchOpts)) {\n          debug('ignored', file, 'rule:', rules[i]);\n          ignored++;\n          matched = true;\n          break;\n        }\n      } else {\n        debug('matched', file, 'rule:', rules[i]);\n\n        if (minimatch(file, rules[i], minimatchOpts)) {\n          watched++; // don't repeat the output if a rule is matched\n\n          if (usedRules.indexOf(rules[i]) === -1) {\n            usedRules.push(rules[i]);\n            utils.log.detail('matched rule: ' + rules[i]);\n          } // if the rule doesn't match the WATCH EVERYTHING\n          // but *does* match a rule that ends with *.*, then\n          // white list it - in that we don't run it through\n          // the extension check too.\n\n\n          if (rules[i] !== '**' + path.sep + '*.*' && rules[i].slice(-3) === '*.*') {\n            whitelist.push(file);\n          } else if (path.basename(file) === path.basename(rules[i])) {\n            // if the file matches the actual rule, then it's put on whitelist\n            whitelist.push(file);\n          } else {\n            good.push(file);\n          }\n\n          matched = true;\n          break;\n        } else {// utils.log.detail('no match: ' + rules[i], file);\n        }\n      }\n    }\n\n    if (!matched) {\n      ignored++;\n    }\n  });\n  debug('good', good); // finally check the good files against the extensions that we're monitoring\n\n  if (ext) {\n    if (ext.indexOf(',') === -1) {\n      ext = '**/*.' + ext;\n    } else {\n      ext = '**/*.{' + ext + '}';\n    }\n\n    good = good.filter(function (file) {\n      // only compare the filename to the extension test\n      return minimatch(path.basename(file), ext, minimatchOpts);\n    });\n  } // else assume *.*\n\n\n  var result = good.concat(whitelist);\n\n  if (utils.isWindows) {\n    // fix for windows testing - I *think* this is okay to do\n    result = result.map(function (file) {\n      return file.slice(0, 1).toLowerCase() + file.slice(1);\n    });\n  }\n\n  return {\n    result: result,\n    ignored: ignored,\n    watched: watched,\n    total: files.length\n  };\n}","map":{"version":3,"names":["minimatch","require","path","fs","debug","utils","module","exports","match","rulesToMonitor","watch","ignore","config","monitor","Array","isArray","length","clone","push","apply","map","rule","cwd","process","not","slice","dir","resolve","stat","statSync","isDirectory","dirs","Error","e","base","tryBaseDir","indexOf","test","dirname","replace","error","isFile","files","ext","rules","sort","a","b","r","split","sep","aIsIgnore","bIsIgnore","s","prefix","substring","good","whitelist","ignored","watched","usedRules","minimatchOpts","dot","isWindows","nocase","forEach","file","matched","i","log","detail","basename","filter","result","concat","toLowerCase","total"],"sources":["/home/dell/node_modules/nodemon/lib/monitor/match.js"],"sourcesContent":["const minimatch = require('minimatch');\nconst path = require('path');\nconst fs = require('fs');\nconst debug = require('debug')('nodemon:match');\nconst utils = require('../utils');\n\nmodule.exports = match;\nmodule.exports.rulesToMonitor = rulesToMonitor;\n\nfunction rulesToMonitor(watch, ignore, config) {\n  var monitor = [];\n\n  if (!Array.isArray(ignore)) {\n    if (ignore) {\n      ignore = [ignore];\n    } else {\n      ignore = [];\n    }\n  }\n\n  if (!Array.isArray(watch)) {\n    if (watch) {\n      watch = [watch];\n    } else {\n      watch = [];\n    }\n  }\n\n  if (watch && watch.length) {\n    monitor = utils.clone(watch);\n  }\n\n  if (ignore) {\n    [].push.apply(monitor, (ignore || []).map(function (rule) {\n      return '!' + rule;\n    }));\n  }\n\n  var cwd = process.cwd();\n\n  // next check if the monitored paths are actual directories\n  // or just patterns - and expand the rule to include *.*\n  monitor = monitor.map(function (rule) {\n    var not = rule.slice(0, 1) === '!';\n\n    if (not) {\n      rule = rule.slice(1);\n    }\n\n    if (rule === '.' || rule === '.*') {\n      rule = '*.*';\n    }\n\n    var dir = path.resolve(cwd, rule);\n\n    try {\n      var stat = fs.statSync(dir);\n      if (stat.isDirectory()) {\n        rule = dir;\n        if (rule.slice(-1) !== '/') {\n          rule += '/';\n        }\n        rule += '**/*';\n\n        // `!not` ... sorry.\n        if (!not) {\n          config.dirs.push(dir);\n        }\n      } else {\n        // ensures we end up in the check that tries to get a base directory\n        // and then adds it to the watch list\n        throw new Error();\n      }\n    } catch (e) {\n      var base = tryBaseDir(dir);\n      if (!not && base) {\n        if (config.dirs.indexOf(base) === -1) {\n          config.dirs.push(base);\n        }\n      }\n    }\n\n    if (rule.slice(-1) === '/') {\n      // just slap on a * anyway\n      rule += '*';\n    }\n\n    // if the url ends with * but not **/* and not *.*\n    // then convert to **/* - somehow it was missed :-\\\n    if (rule.slice(-4) !== '**/*' &&\n      rule.slice(-1) === '*' &&\n      rule.indexOf('*.') === -1) {\n\n      if (rule.slice(-2) !== '**') {\n        rule += '*/*';\n      }\n    }\n\n\n    return (not ? '!' : '') + rule;\n  });\n\n  return monitor;\n}\n\nfunction tryBaseDir(dir) {\n  var stat;\n  if (/[?*\\{\\[]+/.test(dir)) { // if this is pattern, then try to find the base\n    try {\n      var base = path.dirname(dir.replace(/([?*\\{\\[]+.*$)/, 'foo'));\n      stat = fs.statSync(base);\n      if (stat.isDirectory()) {\n        return base;\n      }\n    } catch (error) {\n      // console.log(error);\n    }\n  } else {\n    try {\n      stat = fs.statSync(dir);\n      // if this path is actually a single file that exists, then just monitor\n      // that, *specifically*.\n      if (stat.isFile() || stat.isDirectory()) {\n        return dir;\n      }\n    } catch (e) { }\n  }\n\n  return false;\n}\n\nfunction match(files, monitor, ext) {\n  // sort the rules by highest specificity (based on number of slashes)\n  // ignore rules (!) get sorted highest as they take precedent\n  const cwd = process.cwd();\n  var rules = monitor.sort(function (a, b) {\n    var r = b.split(path.sep).length - a.split(path.sep).length;\n    var aIsIgnore = a.slice(0, 1) === '!';\n    var bIsIgnore = b.slice(0, 1) === '!';\n\n    if (aIsIgnore || bIsIgnore) {\n      if (aIsIgnore) {\n        return -1;\n      }\n\n      return 1;\n    }\n\n    if (r === 0) {\n      return b.length - a.length;\n    }\n    return r;\n  }).map(function (s) {\n    var prefix = s.slice(0, 1);\n\n    if (prefix === '!') {\n      if (s.indexOf('!' + cwd) === 0) {\n        return s;\n      }\n\n      // if it starts with a period, then let's get the relative path\n      if (s.indexOf('!.') === 0) {\n        return '!' + path.resolve(cwd, s.substring(1));\n      }\n\n      return '!**' + (prefix !== path.sep ? path.sep : '') + s.slice(1);\n    }\n\n    // if it starts with a period, then let's get the relative path\n    if (s.indexOf('.') === 0) {\n      return path.resolve(cwd, s);\n    }\n\n    if (s.indexOf(cwd) === 0) {\n      return s;\n    }\n\n    return '**' + (prefix !== path.sep ? path.sep : '') + s;\n  });\n\n  debug('rules', rules);\n\n  var good = [];\n  var whitelist = []; // files that we won't check against the extension\n  var ignored = 0;\n  var watched = 0;\n  var usedRules = [];\n  var minimatchOpts = {\n    dot: true,\n  };\n\n  // enable case-insensitivity on Windows\n  if (utils.isWindows) {\n    minimatchOpts.nocase = true;\n  }\n\n  files.forEach(function (file) {\n    file = path.resolve(cwd, file);\n\n    var matched = false;\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].slice(0, 1) === '!') {\n        if (!minimatch(file, rules[i], minimatchOpts)) {\n          debug('ignored', file, 'rule:', rules[i]);\n          ignored++;\n          matched = true;\n          break;\n        }\n      } else {\n        debug('matched', file, 'rule:', rules[i]);\n        if (minimatch(file, rules[i], minimatchOpts)) {\n          watched++;\n\n          // don't repeat the output if a rule is matched\n          if (usedRules.indexOf(rules[i]) === -1) {\n            usedRules.push(rules[i]);\n            utils.log.detail('matched rule: ' + rules[i]);\n          }\n\n          // if the rule doesn't match the WATCH EVERYTHING\n          // but *does* match a rule that ends with *.*, then\n          // white list it - in that we don't run it through\n          // the extension check too.\n          if (rules[i] !== '**' + path.sep + '*.*' &&\n            rules[i].slice(-3) === '*.*') {\n            whitelist.push(file);\n          } else if (path.basename(file) === path.basename(rules[i])) {\n            // if the file matches the actual rule, then it's put on whitelist\n            whitelist.push(file);\n          } else {\n            good.push(file);\n          }\n          matched = true;\n          break;\n        } else {\n          // utils.log.detail('no match: ' + rules[i], file);\n        }\n      }\n    }\n    if (!matched) {\n      ignored++;\n    }\n  });\n\n  debug('good', good)\n\n  // finally check the good files against the extensions that we're monitoring\n  if (ext) {\n    if (ext.indexOf(',') === -1) {\n      ext = '**/*.' + ext;\n    } else {\n      ext = '**/*.{' + ext + '}';\n    }\n\n    good = good.filter(function (file) {\n      // only compare the filename to the extension test\n      return minimatch(path.basename(file), ext, minimatchOpts);\n    });\n  } // else assume *.*\n\n  var result = good.concat(whitelist);\n\n  if (utils.isWindows) {\n    // fix for windows testing - I *think* this is okay to do\n    result = result.map(function (file) {\n      return file.slice(0, 1).toLowerCase() + file.slice(1);\n    });\n  }\n\n  return {\n    result: result,\n    ignored: ignored,\n    watched: watched,\n    total: files.length,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}